local Concord = require("modules.concord.concord")
local Enum = require("modules.enum.enum")
local Flux = require("modules.flux.flux")
local Gamera = require("modules.gamera.gamera")
local Log = require("modules.log.log")
local Slab = require("modules.slab")
local Timer = require("modules.hump.timer")

local Resources = require("resources")
local Dissolve = require("dissolve")
local Fade = require("fade")
local Image = require("image")
local Inputs = require("inputs")
local MotionBlur = require("motion_blur")
local Palette = require("palette")
local Preloader = require("preloader")
local Save = require("save")
!if not _RELEASE then
local Tracker = require("tracker")
!end

local max = math.max
local min = math.min
local format = string.format
local lower = string.lower
local upper = string.upper
local gsub = string.gsub
local insert = table.insert

local StateMenu = class()
StateMenu.id = "Menu"

local Components = {}
Concord.utils.loadNamespace("components", Components)
local Systems = {
	Animation = require("systems.animation"),
	BoundingBox = require("systems.bounding_box"),
	Click = require("systems.click"),
	Color = require("systems.color"),
	HoverEffect = require("systems.hover_effect"),
	Menu = require("systems.menu"),
	MenuSettings = require("systems.menu_settings"),
	Move = require("systems.move"),
	RenderText = require("systems.render_text"),
	RenderSprite = require("systems.render_sprite"),
	Transform = require("systems.transform"),
}

!if not _RELEASE then
local Systems = Tracker.track(Systems)
!end

local Assemblages = {
	Common = require("assemblages.common")
}

local resources = { images = {}, sources = {}, fonts = {} }
local res_images, res_fonts

local states = Enum("menu", "play", "settings", "about", "exit")
local current_state = states.menu
local options = { "Play", "Settings", "About", "Exit" }
local options_sub = { "Continue", "New Game" }
local is_sub_menu = false
local is_transition = false
local ent_options = {}
local ent_options_sub = {}

local ANGLE_UP = 90
local ANGLE_DOWN = 270
local ANGLE_LEFT = 180
local ANGLE_RIGHT = 0

local duration_show = 0.75
local duration_hide = 0.75
local duration_pos = 0.75
local tx = 176

local tools = {
	"Brave Browser", "Manjaro", "i3-Gaps", "Discord", "Löve Framework",
	"Vim", "Trello", "Aseprite", "Audacity",
}

local libs = {
	"Anim8", "Arson", "Batteries", "Bump-niji", "Concord",
	"Crush", "Enum", "Flux", "Gamera", "HTTPS",
	"HUMP", "JSON", "Lily", "Log", "Luapreprocessor",
	"Lume", "NGrading", "SDF", "Semver", "Slab",
	"Splashes", "TimelineEvents",
}

!if not _RELEASE and _ASSERT then
for i, str in ipairs(options) do
	local lstr = lower(str)
	local test = states[lstr]
end
!end

function StateMenu:on_menu()
	self.world:emit("allow_cursor", true)
	self.world:emit("set_to_prev_cursor")
	self.world:emit("set_page", 1)
end

function StateMenu:show_main_menu(duration)
	for i, e in ipairs(ent_options) do
			e:remove("hidden")
			:give("target_color", Palette.get("white", 1), duration or duration_show)
			:give("lerp_on_complete", function()
				self:on_menu()
				is_transition = false
			end)
			:give("move_to_original", duration or duration_pos)
	end
end

function StateMenu:hide_main_menu(duration)
	for i, e in ipairs(ent_options) do
			e
			:give("target_color", Palette.get("white", 0), duration or duration_hide)
			:give("lerp_on_complete", function()
				e:give("hidden")
			end)
			:give("move_by", vec2:new(tx, 0), duration or duration_pos)
	end
end

function StateMenu:show_sub_menu(duration)
	local next_cursor = 0
	if Save.exists then
		next_cursor = 1
	else
		next_cursor = 2
	end

	for i, e in ipairs(ent_options_sub) do
			e
			:remove("hidden")
			:give("target_color", Palette.get("white", 1), duration or duration_show)
			:give("lerp_on_complete", function()
				self.world:emit("allow_cursor", true)
				self.world:emit("set_cursor", next_cursor)
				is_transition = false
			end)
			:give("move_to_original", duration or duration_pos)
			if next_cursor == 2 and i == 1 then
				e:give("option_disabled")
			end
	end
	self.world:emit("set_page", 2)
end

function StateMenu:hide_sub_menu(duration)
	for i, e in ipairs(ent_options_sub) do
			e
			:give("target_color", Palette.get("white", 0), duration or duration_hide)
			:give("lerp_on_complete", function()
				e:give("hidden")
			end)
			:give("move_by", vec2:new(tx, 0), duration or duration_pos)
	end
end

function StateMenu:turn_off_lamp()
	local ww = love.graphics.getWidth()
	local wh = love.graphics.getHeight()
	local duration = 2
	local timer = 1.75
	-- TODO turn off BGM

	self:hide_sub_menu()
	self.entities.desk:give("hidden")
	self.entities.title
		:give("target_color", Palette.get("white", 0), duration)
	self.entities.subtitle
		:give("target_color", Palette.get("white", 0), duration)

	self.entities.desk_fast = Concord.entity(self.world)
		:assemble(Assemblages.Common.animated_sprite,
			{
				spritesheet = res_images.sheet_desk,
				frames = { "1-3", 1, "1-3", 2, "1-1", 3 },
				delay = 0.001,
				rows_count = 3,
				columns_count = 3,
				n_frames = 7
			}, vec2:new(ww/2, wh/2), false)
		:give("transform", 0, 1, 1, 0.5, 0.5)
		:give("auto_scale", ww, wh, true)
		:give("color", {1, 1, 1, 1})

	Timer.after(timer, function()
		-- TODO add sudden static sound
		self.entities.desk_fast:give("hidden")
	end)
end

function StateMenu:on_play()
	is_transition = true
	is_sub_menu = true
	self.world:emit("allow_cursor", false)
	self:hide_main_menu()
	self:show_sub_menu()
end

function StateMenu:on_newgame()
	self:turn_off_lamp()
	self.gamestate.switch("Intro")
end

function StateMenu:on_continue()
	-- TODO load saved game here
end

function StateMenu:on_settings()
	self.world:emit("allow_cursor", false)
	local l, t, w, h = self.camera:getWorld()
	local cworld = { x = l, y = t, w = w, h = h }
	self.world:emit("init_settings")
	self:MB_move(cworld.w, nil, ANGLE_RIGHT)
end

function StateMenu:on_about()
	self:setup_about()
	self.world:emit("allow_cursor", false)
	local l, t, w, h = self.camera:getWorld()
	local cworld = { x = l, y = t, w = w, h = h }
	self:MB_move(nil, cworld.h, ANGLE_UP)
end

function StateMenu:on_exit()
	self.world:emit("allow_cursor", false)
	!if _PLATFORM == "desktop" then
		local btn = love.window.showMessageBox("Alert",
			"Are you sure you want to exit the game?",
			{ "Exit", "Cancel", escapebutton = 2 })
		if btn == 1 then
			self:hide_main_menu()
			self.dissolve_ff.flag_process = true
			self.dissolve_ff.on_complete = function()
				love.event.quit()
			end
		elseif btn == 2 then
			current_state = states.menu
			Log.info("Switched Menu State to: ", current_state)
			self:on_menu()
		end
	!end
end

function StateMenu:setup_menu()
	local ww = love.graphics.getWidth()
	local wh = love.graphics.getHeight()
	local bg_door = res_images.bg_door
	local bg_hallway = res_images.bg_hallway
	local title = res_images.title
	local subtitle = res_images.subtitle

	local bg_hw_w, bg_hw_h = bg_hallway:getDimensions()
	local bg_door_w, bg_door_h = bg_door:getDimensions()
	local title_w, title_h = title:getDimensions()
	local subt_w, subt_h = subtitle:getDimensions()

	local scale = min(ww/bg_door_w, wh/bg_door_h)
	local scale_hallway = min(ww/bg_hw_w, wh/bg_hw_h)
	local scale_title = min((bg_door_w * scale)/title_w, (bg_door_h * scale)/title_h)
	local scale_subt = min((title_w * scale_title)/subt_w, (title_h * scale)/subt_h)
	scale_subt = scale_subt * 0.75

	self.entities.bg_door = Concord.entity(self.world)
		:give("position", vec2:new(ww * 1.5, wh/2))
		:give("sprite", bg_door)
		:give("transform", 0, scale, scale, bg_door_w/2, bg_door_h/2)

	self.entities.bg_hallway = Concord.entity(self.world)
		:give("position", vec2:new(ww/2, wh * 1.5))
		:give("sprite", bg_hallway)
		:give("transform", 0, scale_hallway, scale_hallway, bg_hw_w/2, bg_hw_h/2)

	self.entities.desk = Concord.entity(self.world)
		:assemble(Assemblages.Common.animated_sprite,
			{
				spritesheet = res_images.sheet_desk,
				frames = { "1-3", 1, "1-3", 2, "1-1", 3 },
				durations = { 1, 0.1, 1, 0.1, 0.1, 0.1, 1  },
				rows_count = 3,
				columns_count = 3,
				n_frames = 7
			},
			vec2:new(ww/2, wh/2), false)
		:give("transform", 0, 1, 1, 0.5, 0.5)
		:give("auto_scale", ww, wh, true)
		:give("color", {1, 1, 1, 1})

	self.entities.title = Concord.entity(self.world)
		:give("position", vec2:new(ww * 0.25, wh/2 - 36))
		:give("sprite", title)
		:give("transform", 0, scale_title, scale_title, title_w/2, title_h/2)
		:give("color", {1, 1, 1, 0.4})

	self.entities.subtitle = Concord.entity(self.world)
		:give("position", vec2:new(ww * 0.25, wh * 1.5))
		:give("anchor", self.entities.title, "center", "bottom")
		:give("sprite", subtitle)
		:give("color", {1, 1, 1, 0.4})
		:give("transform", 0, scale_subt, scale_subt, subt_w/2, subt_h/2)

	local jamboree_fnt = "res/fonts/Jamboree.fnt"
	local jamboree_png = "res/fonts/Jamboree.png"
	local sdf_menu = love.graphics.newFontMSDF(jamboree_fnt, jamboree_png)
	local font_menu = res_fonts.menu
	local str_target_h = font_menu:getHeight()
	local str_h = sdf_menu:getHeight()
	local scale = str_target_h/str_h * 0.75
	local offset = 16
	local padding = 2

	for i, str in ipairs(options) do
		local lstr = lower(str)
		local str_w = sdf_menu:getWidth(str) * scale
		local x = self.canvases.bot_canvas.width - str_w - offset
		local y = self.canvases.bot_canvas.y + (i * str_h) + (padding * i) - offset

		local id = "text_" .. lstr
		self.entities[id] = Concord.entity(self.world)
			:assemble(Assemblages.Common.text,
				vec2:new(x, y), str, sdf_menu, Palette.get("white", 1))
			:give("sdf", scale, scale)
			:give("option_key", i, 1)
			:give("on_enter", function()
				current_state = states[lstr]
				Log.info("Switched Menu State to: ", current_state)
				self["on_" .. lstr](self)
			end)
		insert(ent_options, self.entities[id])
	end

	for i, str in ipairs(options_sub) do
		local lstr = lower(str)
		lstr = gsub(lstr, "%s+", "")
		local str_w = sdf_menu:getWidth(str) * scale
		local x = self.canvases.bot_canvas.width - str_w - offset
		local y = self.canvases.bot_canvas.y + (i * str_h) + (padding * i) - offset

		local id = "text_sub_" .. lstr
		self.entities[id] = Concord.entity(self.world)
			:assemble(Assemblages.Common.text,
				vec2:new(x, y), str, sdf_menu, Palette.get("white", 1))
			:give("sdf", scale, scale)
			:give("option_key", i, 2)
			:give("on_enter", function()
				self["on_" .. lstr](self)
			end)
		insert(ent_options_sub, self.entities[id])
	end
end

local function generate_about()
	local t = {
		{ upper(!(_GAME_TITLE)), res_fonts.about_64, 12},
		{ "A Game By:" },
		{ "Brandon Blanker Lim-it @flamendless" },
		{ "Arts By:" },
		{ "Conrad Reyes @wits" },

		{ "@LAYOUT:LEFT" },
		{ "TOOLS USED:" },
	}

	for i = 1, #tools, 2 do
		local a = tools[i]
		local b = tools[i + 1] or ""
		local subt = { format("%s, %s", a, b) }
		insert(t, subt)
	end

	insert(t, { "@LAYOUT:RIGHT" })
	insert(t, { "LIBRARIES USED:" })

	for i = 1, #libs, 3 do
		local a = libs[i]
		local b = libs[i + 1] or ""
		local c = libs[i + 2] or ""
		local subt = { format("%s, %s, %s", a, b, c) }
		insert(t, subt)
	end

	insert(t, { "@LAYOUT:CENTER" })
	insert(t, { "" })
	insert(t, { "SPECIAL THANKS to the people at the Löve Discord server:" })
	insert(t, { "" })
	insert(t, { res_images.twitter, res_images.website, res_images.mail })

	return t
end

function StateMenu:setup_about()
	local about = generate_about()
	local about_links = { !(_URL_TWITTER), !(_URL_WEBSITE), !(_URL_MAIL), }

	local l, t, w, h = self.camera:getVisible()
	local font_about = res_fonts.about_24
	local base_x = w/2
	local base_y = h + 16
	local layout = false
	local layout_base_y = 0
	local largest = 0
	for i, el in ipairs(about) do
		if type(el[1]) == "string" then
			local str = el[1]
			local font = el[2] or font_about
			local space = el[3]
			local str_w = font:getWidth(str)
			local str_h = font:getHeight(str)
			local x = base_x - str_w/2
			local y = base_y
			if space then base_y = base_y + space end
			if str == "@LAYOUT:LEFT" then
				base_x = w * 0.25
				layout_base_y = base_y
				layout = true
			elseif str == "@LAYOUT:RIGHT" then
				base_x = w * 0.75
				layout_base_y = base_y
				layout = true
			elseif str == "@LAYOUT:CENTER" then
				base_x = w/2
				base_y = largest
				layout = false
			else
				if layout then
					y = layout_base_y
					layout_base_y = layout_base_y + str_h
					largest = max(largest, layout_base_y)
				end
				local id = "about_text_" .. i
				self.entities[id] = Concord.entity(self.world)
					:assemble(Assemblages.Common.static_text,
						vec2:new(x, y), str, font, Palette.colors.white)
					:give("position", vec2:new(x, y))
					:give("camera")

				if not layout then base_y = base_y + str_h end
			end

		elseif el[1].type and el[1]:type() == "Image" then
			local pad = 32
			local img_h
			for i2, image in ipairs(el) do
				local id = "about_image_" .. (i + i2)
				local image_base_x = base_x - (#el/2 * image:getWidth()) - pad
				local x = image_base_x + (image:getWidth() + pad) * (i2 - 1)
				local y = base_y + image:getHeight()/2 - pad
				img_h = image:getHeight()
				self.entities[id] = Concord.entity(self.world)
					:give("sprite", image)
					:give("position", vec2:new(x, y))
					:give("color", Palette.colors.white)
					:give("camera")
					:give("bounding_box", x, y, image:getWidth(), image:getHeight())
					:give("clickable", 1, function()
						local url = about_links[i2]
						love.system.openURL(url)
					end)
					:give("hoverable")
					:give("hover_change_color", Palette.colors.red, 0.5)

					!if not _RELEASE then
					self.entities[id]:give("bounding_box_color", {1, 0, 0, 0.5})
					!end
			end
			base_y = base_y + img_h + pad
		end
	end
end

function StateMenu:new()
	return self:init({
		camera = nil,
		world = Concord.world(),
		entities = {},
		canvases = {},
		is_ready = false,
		gamestate = nil,
	})
end

function StateMenu:load()
	Log.info("State Load: ", self.id)
	local resources_data = Resources.get("menu")
	Preloader.start(resources_data, resources,
		function()
			-- TODO play BGM
			self.is_ready = true
			self:start()
			Slab.Initialize()
		end)
end

function StateMenu:start()
	local ww = love.graphics.getWidth()
	local wh = love.graphics.getHeight()

	res_images = resources.images
	res_fonts = resources.fonts

	self.camera = Gamera.new(0, 0, ww * 2, wh * 2)
	self.camera:setWindow(0, 0, ww, wh)
	self.canvas_main = self.canvases.main_canvas
	self.mb_main = MotionBlur:new(self.canvas_main)

	local img_ff = Image.resize_image(res_images.flowfield)
	self.dissolve_ff = Dissolve:new(img_ff, 2)

	self.world:addSystem(Systems.Animation)
	self.world:addSystems(Systems.RenderSprite)
	self.world:addSystems(Systems.RenderText)
	self.world:addSystems(Systems.Menu)
	self.world:addSystems(Systems.Click)
	self.world:addSystems(Systems.Color)
	self.world:addSystems(Systems.BoundingBox)
	self.world:addSystems(Systems.HoverEffect)
	self.world:addSystems(Systems.Transform)
	self.world:addSystems(Systems.Move)
	self.world:addSystems(Systems.MenuSettings)

	!if not _RELEASE then
	Tracker.warn_on_ref_count(Systems, 0)
	!end

	self:setup_menu()

	self:hide_main_menu(0.1)
	self:hide_sub_menu(0.1)

	Fade.set_color({0, 0, 0, 1})
	Fade.fade_in(function()
		self.world:emit("allow_cursor", true)
		self.world:emit("set_cursor", 1)
		self.entities.subtitle:remove("anchor")
		self:show_main_menu()
	end, 1.5, 0.25)
end

function StateMenu:update(dt)
	if not self.is_ready then return end
	local mx, my = love.mouse.getPosition()
	self.world:emit("update", dt)
	self.world:emit("change_color", mx, my)

	if current_state == states.settings and not self.mb_main.flag_process then
		self.world:emit("update_settings", dt)
	elseif current_state == states.exit then
		self.dissolve_ff:update(dt)
	end
end

function StateMenu:draw()
	if not self.is_ready then return end
	love.graphics.setColor(1, 1, 1, 1)

	if current_state == states.menu or
		current_state == states.settings or
		current_state == states.about or
		current_state == states.play then
		self.canvas_main:attach()
		self.camera:draw(function(l, t, w, h)
			self.world:emit("draw")
			if current_state == states.settings and not self.mb_main.flag_process then
				love.graphics.push()
				love.graphics.translate(l, t)
				self.world:emit("draw_settings")
				love.graphics.pop()
			end
			Fade.draw()
		end)
		self.canvas_main:detach()
		self.mb_main:post_process_draw()
	elseif current_state == states.exit then
		self.dissolve_ff:draw(function()
			self.world:emit("draw")
		end)
	end
end

function StateMenu:keypressed(key)
	if not self.is_ready then return end
	local dt = 0
	-- TODO add keypress sounds (up = down, enter, disabled, escape)
	if Inputs.is_pressed("ui_down", key) then
		dt = 1
	elseif Inputs.is_pressed("ui_up", key) then
		dt = -1
	end
	if Inputs.is_pressed("ui_interact", key) and not is_transition then
		self.world:emit("enter_option")
	end
	self.world:emit("update_cursor", dt)

	if Inputs.is_pressed("ui_back", key) then
		if current_state == states.play and is_sub_menu and not is_transition then
			is_transition = true
			is_sub_menu = false
			self.world:emit("allow_cursor", false)
			self:hide_sub_menu()
			self:show_main_menu()
		elseif current_state ~= states.menu and current_state ~= states.play then
			self:MB_return()
		end
	end
end

function StateMenu:mousepressed(mx, my, mb)
	if not self.is_ready then return end
	self.world:emit("mousepressed", mb, mx, my)
end

function StateMenu:MB_move(tx, ty, angle)
	-- TODO add motion blur sound
	self.mb_main.flag_process = true
	local l, t, w, h = self.camera:getWorld()
	local cx, cy = self.camera:getPosition()
	local cworld = { x = l, y = t, w = w, h = h }
	local cpos = vec2:new(cx, cy)
	local duration = 1
	local distance = { 1.0 }
	local prev_angle = (angle + 180) % 360

	Flux.to(cpos, duration, { x = tx, y = ty })
		:onstart(function()
			self.mb_main:store_previous(cx, cy, prev_angle)
			self.mb_main:set_angle(angle)
			Flux.to(distance, duration, { [1] = 0.0 })
				:onupdate(function()
					self.mb_main:set_strength(distance[1])
				end)
		end)
		:onupdate(function()
			self.camera:setPosition(cpos.x, cpos.y)
			self.world:emit("on_camera_move", self.camera)
		end)
		:oncomplete(function()
			self.mb_main.flag_process = false
		end)
end

function StateMenu:MB_return()
	-- TODO add motion blur sound
	self.mb_main.flag_process = true
	local l, t, w, h = self.camera:getWorld()
	local cx, cy = self.camera:getPosition()
	local cworld = { x = l, y = t, w = w, h = h }
	local cpos = vec2:new(cx, cy)
	local duration = 1
	local distance = { 1.0 }
	local temp_mb = self.mb_main.previous

	Flux.to(cpos, duration, { x = temp_mb.target.x, y = temp_mb.target.y })
		:onstart(function()
			self.mb_main:set_angle(temp_mb.angle)
			Flux.to(distance, duration, { [1] = 0.0 })
				:onupdate(function()
					self.mb_main:set_strength(distance[1])
				end)
		end)
		:onupdate(function()
			self.camera:setPosition(cpos.x, cpos.y)
			self.world:emit("on_camera_move", self.camera)
		end)
		:oncomplete(function()
			current_state = states.menu
			Log.info("Switched Menu State to: ", current_state)
			self.mb_main.flag_process = false
			self:on_menu()
		end)
end

function StateMenu:exit()
	Timer.clear()
	Resources.clean(resources)
	for i, e in ipairs(self.world:getEntities()) do
		e:destroy()
	end
	for k, e in pairs(self.entities) do
		self.entities[k]:destroy()
		self.entities[k] = nil
	end
	for i, e in ipairs(ent_options) do
		e:destroy()
		ent_options[i] = nil
	end
	for i, e in ipairs(ent_options_sub) do
		e:destroy()
		ent_options_sub[i] = nil
	end
	current_state = states.menu
	is_sub_menu = false
	is_transition = false
end

return StateMenu
